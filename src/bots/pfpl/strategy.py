# src/bots/pfpl/strategy.py
from __future__ import annotations
import os
import logging
from typing import Any
import asyncio
import hmac
import hashlib
import json
import time
from decimal import Decimal
from hl_core.utils.logger import setup_logger
from pathlib import Path

try:  # pragma: no cover - PyYAML may be absent in the test environment
    import yaml  # type: ignore
except Exception:  # noqa: F401 - fallback when PyYAML isn't installed
    import json as _json

    class _YAMLModule:  # minimal shim with safe_load
        @staticmethod
        def safe_load(stream: str):  # type: ignore[override]
            try:
                return _json.loads(stream)
            except Exception:
                return {}

    yaml = _YAMLModule()  # type: ignore

import anyio
from datetime import datetime, timezone  # ‚Üê ËøΩÂä†

# Êó¢Â≠ò import Áæ§„ÅÆÊúÄÂæå„ÅÇ„Åü„Çä„Å´ËøΩÂä†
from hyperliquid.exchange import Exchange

try:  # pragma: no cover - eth_account is optional for tests
    from eth_account.account import Account  # type: ignore
except Exception:  # noqa: F401 - fallback when eth_account isn't installed

    class Account:  # type: ignore
        @staticmethod
        def from_key(key: str):
            class _Wallet:
                def __init__(self, key: str) -> None:
                    self.key = key

            return _Wallet(key)


logger = logging.getLogger(__name__)


class PFPLStrategy:
    """Price-Fair-Price-Lag bot"""

    # ‚Üê „Ç∑„Ç∞„Éç„ÉÅ„É£„ÅØ„Åù„ÅÆ„Åæ„Åæ
    _LOGGER_INITIALISED = False
    _FILE_HANDLERS: set[str] = set()

    def __init__(
        self, *, config: dict[str, Any], semaphore: asyncio.Semaphore | None = None
    ):
        if not PFPLStrategy._LOGGER_INITIALISED:
            setup_logger(bot_name="pfpl")
            PFPLStrategy._LOGGER_INITIALISED = True
        # ‚îÄ‚îÄ ‚ë† YAML „Å® CLI „ÅÆ„Éû„Éº„Ç∏ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        yml_path = Path(__file__).with_name("config.yaml")
        yaml_conf: dict[str, Any] = {}
        if yml_path.exists():
            with yml_path.open(encoding="utf-8") as f:
                raw_conf = f.read()
            yaml_conf = yaml.safe_load(raw_conf) or {}
        self.config = {**yaml_conf, **config}
        # --- Funding Áõ¥Ââç„ÇØ„É≠„Éº„Ç∫Áî®„Éê„ÉÉ„Éï„Ç°ÁßíÊï∞Ôºà„Éá„Éï„Ç©„É´„Éà 120Ôºâ
        self.funding_close_buffer_secs: int = int(
            getattr(self, "cfg", getattr(self, "config", {})).get(
                "funding_close_buffer_secs", 120
            )
        )
        # --- Order price offset percentageÔºà„Éá„Éï„Ç©„É´„Éà 0.0005 = 0.05 %Ôºâ
        self.eps_pct: float = float(self.config.get("eps_pct", 0.0005))

        # ‚îÄ‚îÄ ‚ë° ÈÄöË≤®„Éö„Ç¢„ÉªSemaphore ÂàùÊúüÂåñ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        self.symbol: str = self.config.get("target_symbol", "ETH-PERP")
        sym_parts = self.symbol.split("-", 1)
        self.base_coin: str = sym_parts[0] if sym_parts else self.symbol

        max_ops = int(self.config.get("max_order_per_sec", 3))  # 1 Áßí„ÅÇ„Åü„ÇäÁô∫Ê≥®‰∏äÈôê
        self.sem: asyncio.Semaphore = semaphore or asyncio.Semaphore(max_ops)

        # ‰ª•Èôç (env Ë™≠„ÅøËæº„Åø„ÉªSDK ÂàùÊúüÂåñ ‚Ä¶) „ÅØÂæìÊù•„Ç≥„Éº„Éâ„ÇíÁ∂ö„Åë„Çã
        # ------------------------------------------------------------------

        # ‚îÄ‚îÄ Áí∞Â¢ÉÂ§âÊï∞„Ç≠„Éº ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        account = os.getenv("HL_ACCOUNT_ADDR")
        secret = os.getenv("HL_API_SECRET")
        if not (account and secret):
            raise RuntimeError("HL_ACCOUNT_ADDR / HL_API_SECRET „ÅåÊú™Ë®≠ÂÆö")
        self.account: str = account
        self.secret: str = secret

        # ‚îÄ‚îÄ Hyperliquid SDK ÂàùÊúüÂåñ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        self.wallet = Account.from_key(self.secret)
        base_url = (
            "https://api.hyperliquid-testnet.xyz"
            if self.config.get("testnet")
            else "https://api.hyperliquid.xyz"
        )
        self.exchange = Exchange(
            self.wallet,
            base_url,
            account_address=self.account,
        )

        # ‚îÄ‚îÄ meta ÊÉÖÂ†±„Åã„Çâ tick / min_usd Ê±∫ÂÆö ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        meta = self.exchange.info.meta()

        # min_usd
        if min_usd_cfg := self.config.get("min_usd"):
            self.min_usd = Decimal(str(min_usd_cfg))
            logger.info("min_usd override from config: USD %.2f", self.min_usd)
        else:
            min_usd_map: dict[str, str] = meta.get("minSizeUsd", {})
            min_usd_raw = min_usd_map.get(self.base_coin)
            if min_usd_raw is not None:
                self.min_usd = Decimal(str(min_usd_raw))
                logger.info(
                    "min_usd from meta for %s: USD %.2f", self.base_coin, self.min_usd
                )
            else:
                self.min_usd = Decimal("1")
                logger.warning(
                    "minSizeUsd missing for %s ‚ûú fallback USD 1", self.base_coin
                )

        # tick
        uni_entry = next(u for u in meta["universe"] if u["name"] == self.base_coin)
        tick_raw = uni_entry.get("pxTick") or uni_entry.get("pxTickSize", "0.01")
        self.tick = Decimal(str(tick_raw))
        logger.info("pxTick for %s: %s", self.base_coin, self.tick)

        # ‚îÄ‚îÄ Bot „Éë„É©„É°„Éº„Çø ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        self.cooldown = float(self.config.get("cooldown_sec", 1.0))
        self.order_usd = Decimal(self.config.get("order_usd", 10))
        self.max_pos = Decimal(self.config.get("max_position_usd", 100))
        self.fair_feed = self.config.get("fair_feed", "indexPrices")
        self.max_daily_orders = int(self.config.get("max_daily_orders", 500))
        self._order_count = 0
        self._start_day = datetime.now(timezone.utc).date()
        self.enabled = True
        # ‚îÄ‚îÄ „Éï„Ç£„Éº„Éâ‰øùÊåÅÁî® -------------------------------------------------
        self.mid: Decimal | None = None  # Êùø Mid (@1)
        self.idx: Decimal | None = None  # indexPrices
        self.ora: Decimal | None = None  # oraclePrices
        self.fair: Decimal | None = None  # Âπ≥Âùá„Åó„ÅüÂÖ¨Ê≠£‰æ°Ê†º

        # ‚îÄ‚îÄ ÂÜÖÈÉ®„Çπ„ÉÜ„Éº„Éà ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        self.last_side: str | None = None
        self.last_ts: float = 0.0
        self.pos_usd = Decimal("0")
        # ‚òÖ Funding Guard Áî®
        self.next_funding_ts: float | None = None  # Áõ¥Ëøë funding ‰∫àÂÆö„ÅÆ UNIX Áßí
        self._funding_pause: bool = False  # True „Å™„ÇâÂ£≤Ë≤∑ÂÅúÊ≠¢‰∏≠
        # ÈùûÂêåÊúü„Åß„Éù„Ç∏„Ç∑„Éß„É≥ÂàùÊúüÂåñ
        try:
            asyncio.get_running_loop().create_task(self._refresh_position())
        except RuntimeError:
            pass  # pytest ÂèéÈõÜÊôÇ„Å™„Å©„ÄÅ„Ç§„Éô„É≥„Éà„É´„Éº„Éó„ÅåÁÑ°„ÅÑÂ†¥Âêà

        # ‚îÄ‚îÄ‚îÄ „Åì„Åì„Åã„ÇâËøΩÂä†Ôºà„É≠„Ç¨„Éº„Çí„Éö„Ç¢„Åî„Å®„ÅÆ„Éï„Ç°„Ç§„É´„Å∏„ÇÇÂá∫ÂäõÔºâ‚îÄ‚îÄ‚îÄ‚îÄ
        if self.symbol not in PFPLStrategy._FILE_HANDLERS:
            h = logging.FileHandler(f"strategy_{self.symbol}.log", encoding="utf-8")
            h.setFormatter(logging.Formatter("%(asctime)s %(levelname)s %(message)s"))
            logging.getLogger().addHandler(h)
            PFPLStrategy._FILE_HANDLERS.add(self.symbol)

        logger.info("PFPLStrategy initialised with %s", self.config)

    # ‚îÄ‚îÄ src/bots/pfpl/strategy.py ‚îÄ‚îÄ
    async def _refresh_position(self) -> None:
        """
        ÁèæÂú®„ÅÆ ETH-PERP Âª∫Áéâ USD „Çí self.pos_usd „Å´ÂèçÊò†„ÄÇ
        perpPositions „ÅåÁÑ°„ÅÑÂè£Â∫ß„Åß„ÇÇËêΩ„Å°„Å™„ÅÑ„ÄÇ
        """
        try:
            state = self.exchange.info.user_state(self.account)

            # ‚Äï‚Äï ETH „ÅÆ perp Âª∫Áéâ„ÇíÊäΩÂá∫ÔºàÁÑ°„ÅÑÂ†¥Âêà„ÅØ NoneÔºâ
            perp_pos = next(
                (
                    p
                    for p in state.get("perpPositions", [])  # ‚Üê üîë get(..., [])
                    if p["position"]["coin"] == "ETH"
                ),
                None,
            )

            usd = (
                Decimal(perp_pos["position"]["sz"])
                * Decimal(perp_pos["position"]["entryPx"])
                if perp_pos
                else Decimal("0")
            )
            self.pos_usd = usd
            logger.debug("pos_usd refreshed: %.2f", usd)
        except Exception as exc:  # ‚Üê „Åì„Åì„ÅßÊè°„Çä„Å§„Å∂„Åô
            logger.warning("refresh_position failed: %s", exc)

    # ‚ë° ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # ------------------------------------------------------------------ WS hook
    def on_message(self, msg: dict[str, Any]) -> None:
        ch = msg.get("channel")

        if ch == "allMids":  # Êùø mid Áæ§
            self.mid = Decimal(msg["data"]["mids"]["@1"])
        elif ch == "indexPrices":  # „Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ‰æ°Ê†º
            prices = (msg.get("data") or {}).get("prices", {})
            price_val = prices.get(self.base_coin)
            if price_val is not None:
                self.idx = Decimal(str(price_val))
        elif ch == "oraclePrices":  # „Ç™„É©„ÇØ„É´‰æ°Ê†º
            prices = (msg.get("data") or {}).get("prices", {})
            price_val = prices.get(self.base_coin)
            if price_val is not None:
                self.ora = Decimal(str(price_val))
        elif msg.get("channel") == "fundingInfo":
            data = msg.get("data", {})
            next_ts = data.get("nextFundingTime") if isinstance(data, dict) else None
            if next_ts is None and isinstance(data, dict):
                info = data.get(self.symbol)
                if isinstance(info, dict):
                    next_ts = info.get("nextFundingTime")
            if next_ts is None and isinstance(data, dict):
                base_info = data.get(self.base_coin)
                if isinstance(base_info, dict):
                    next_ts = base_info.get("nextFundingTime")
            if next_ts is not None:
                self.next_funding_ts = float(next_ts)
                logger.debug("fundingInfo: next @ %s", self.next_funding_ts)

        # fair „Åå‰Ωú„Çå„Çå„Å∞Ë©ï‰æ°„Å∏
        if self.mid is not None and self.idx is not None and self.ora is not None:
            self.fair = (self.idx + self.ora) / 2  # ‚òÖ Âπ≥Âùá„ÅßÂÖ¨Ê≠£‰æ°Ê†º
            self.evaluate()

    # ---------------------------------------------------------------- evaluate

    # src/bots/pfpl/strategy.py
    # ------------------------------------------------------------------ Tick loop
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    def evaluate(self) -> None:
        if not self._check_funding_window():
            return
        # ‚îÄ‚îÄ fair / mid „Åå„Åæ„Å†ÊèÉ„Å£„Å¶„ÅÑ„Å™„ÅÑ„Å™„Çâ‰Ωï„ÇÇ„Åó„Å™„ÅÑ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if self.mid is None or self.fair is None:
            return
        now = time.time()
        # 0) --- Funding Áõ¥Ââç„ÇØ„É≠„Éº„Ç∫Âà§ÂÆö -----------------------------------
        if self._should_close_before_funding(now):
            asyncio.create_task(self._close_all_positions())
            return  # ‰ªäÂõû„ÅÆ evaluate „ÅØ„Åì„Åì„ÅßÁµÇ‰∫Ü

        # --- „É™„Çπ„ÇØ„Ç¨„Éº„Éâ ------------------
        if not self._check_limits():
            return
        # ‚ë† „ÇØ„Éº„É´„ÉÄ„Ç¶„É≥Âà§ÂÆö
        if now - self.last_ts < self.cooldown:
            return

        # ‚ë° ÊúÄÂ§ßÂª∫ÁéâÂà§ÂÆö
        if abs(self.pos_usd) >= self.max_pos:
            return

        # ‚ë¢ ÂøÖË¶Å„Éá„Éº„ÇøÂèñÂæó
        mid = self.mid
        fair = self.fair
        if mid is None or fair is None:
            return  # „Éá„Éº„Çø„ÅåÊèÉ„Å£„Å¶„ÅÑ„Å™„ÅÑ

        abs_diff = abs(fair - mid)  # USD Â∑Æ
        pct_diff = abs_diff / mid * Decimal("100")  # ‰πñÈõ¢Áéá %

        # ‚ë£ ÈñæÂÄ§Âà§ÂÆö
        th_abs = Decimal(str(self.config.get("threshold", "1.0")))  # USD
        th_pct = Decimal(str(self.config.get("threshold_pct", "0.05")))  # %
        mode = self.config.get("mode", "both")  # both / either

        if mode == "abs":
            if abs_diff < th_abs:
                return
        elif mode == "pct":
            if pct_diff < th_pct:
                return
        elif mode == "either":
            if abs_diff < th_abs and pct_diff < th_pct:
                return
        else:  # default = both
            if abs_diff < th_abs or pct_diff < th_pct:
                return

        # ‚ë§ Áô∫Ê≥®„Çµ„Ç§„ÉâÊ±∫ÂÆö
        side = "BUY" if fair < mid else "SELL"

        # ‚ë• ÈÄ£Á∂öÂêåÊñπÂêëÈò≤Ê≠¢
        if side == self.last_side and now - self.last_ts < self.cooldown:
            return

        # ‚ë¶ Áô∫Ê≥®„Çµ„Ç§„Ç∫Ë®àÁÆó
        size = (self.order_usd / mid).quantize(self.tick)
        if size * mid < self.min_usd:
            logger.debug(
                "size %.4f USD %.2f < min_usd %.2f ‚Üí skip",
                size,
                size * mid,
                self.min_usd,
            )
            return

        # ‚ëß Âª∫ÁéâË∂ÖÈÅé„ÉÅ„Çß„ÉÉ„ÇØ
        if (
            abs(self.pos_usd + (size * mid if side == "BUY" else -size * mid))
            > self.max_pos
        ):
            logger.debug("pos_limit %.2f USD Ë∂ÖÈÅé ‚Üí skip", self.max_pos)
            return

        # ‚ë® Áô∫Ê≥®
        asyncio.create_task(self.place_order(side, float(size)))

    # ---------------------------------------------------------------- order

    async def place_order(
        self,
        side: str,
        size: float,
        *,
        order_type: str = "limit",
        limit_px: float | None = None,
        **kwargs,
    ) -> None:
        """IOC „ÅßÂç≥ÊôÇÁ¥ÑÂÆö„ÄÅÂ§±ÊïóÊôÇ„É™„Éà„É©„Ç§‰ªò„Åç"""
        is_buy = side == "BUY"
        mid_value = self.mid

        # ‚îÄ‚îÄ Dry-run ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if self.config.get("dry_run"):
            logger.info("[DRY-RUN] %s %.4f %s", side, size, self.symbol)
            self.last_ts = time.time()
            self.last_side = side
            return
        # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        # --- eps_pct „ÇíÈÅ©Áî®„Åó„Åü‰æ°Ê†ºË£úÊ≠£ -------------------------------
        if order_type == "limit":
            if mid_value is None:
                logger.warning("mid price unavailable; skip order placement")
                return
            limit_px = (
                limit_px
                if limit_px is not None
                else self._price_with_offset(float(mid_value), side)
            )

        if mid_value is None:
            logger.warning("mid price unavailable; skip order placement")
            return

        async with self.sem:  # 1 Áßí„ÅÇ„Åü„ÇäÁô∫Ê≥®Âà∂Âæ°
            MAX_RETRY = 3
            order_fn = getattr(self.exchange, "order", None)
            if not callable(order_fn):
                raise AttributeError("exchange.order is not callable")
            for attempt in range(1, MAX_RETRY + 1):
                try:
                    resp = order_fn(
                        coin=self.symbol,
                        is_buy=is_buy,
                        sz=float(size),
                        limit_px=limit_px,
                        order_type={"limit": {"tif": "Ioc"}},  # IOC ÊåáÂÆö
                        reduce_only=False,
                    )
                    logger.info("ORDER OK %s try=%d ‚Üí %s", self.symbol, attempt, resp)
                    self._order_count += 1
                    self.last_ts = time.time()
                    self.last_side = side
                    break
                except Exception as exc:
                    logger.error(
                        "ORDER FAIL %s try=%d/%d: %s",
                        self.symbol,
                        attempt,
                        MAX_RETRY,
                        exc,
                    )
                    if attempt == MAX_RETRY:
                        logger.error(
                            "GIVE-UP %s after %d retries", self.symbol, MAX_RETRY
                        )
                    else:
                        await anyio.sleep(0.5)

    def _sign(self, payload: dict[str, Any]) -> str:
        """API Wallet Secret „Åß HMAC-SHA256 ÁΩ≤ÂêçÔºà‰æãÔºâ"""
        msg = json.dumps(payload, separators=(",", ":")).encode()
        return hmac.new(self.secret.encode(), msg, hashlib.sha256).hexdigest()

    # ------------------------------------------------------------------ limits
    def _check_limits(self) -> bool:
        """Êó•Ê¨°„ÅÆÁô∫Ê≥®Êï∞„Å®Âª∫ÁéâÂà∂Èôê„ÇíË∂Ö„Åà„Å¶„ÅÑ„Å™„ÅÑ„ÅãÁ¢∫Ë™ç"""
        today = datetime.now(timezone.utc).date()
        if today != self._start_day:  # Êó•‰ªò„ÅåÂ§â„Çè„Å£„Åü„Çâ„É™„Çª„ÉÉ„Éà
            self._start_day = today
            self._order_count = 0

        if self._order_count >= self.max_daily_orders:
            logger.warning("daily order-limit reached ‚Üí trading disabled")
            return False

        if abs(self.pos_usd) >= self.max_pos:
            logger.warning("position limit %.2f USD reached", self.max_pos)
            return False

        return True

    def _check_funding_window(self) -> bool:
        """
        funding Áõ¥Ââç„ÉªÁõ¥Âæå„ÅØ True „ÇíËøî„Åï„Åö evaluate() „ÇíÂÅúÊ≠¢„Åï„Åõ„Çã„ÄÇ
        - 5 ÂàÜÂâç „Äú 2 ÂàÜÂæå „Çí„ÄåÂç±Èô∫Á™ì„Äç„Å®„Åô„Çã
        """
        if self.next_funding_ts is None:
            return True  # fundingInfo Êú™ÂèñÂæó„Å™„ÇâÈÄöÂ∏∏ÈÅãËª¢

        now = time.time()
        before = 300  # 5 ÂàÜÂâç
        after = 120  # 2 ÂàÜÂæå

        in_window = self.next_funding_ts - before <= now <= self.next_funding_ts + after

        if in_window and not self._funding_pause:
            logger.info("‚è≥ Funding window ‚ûú Â£≤Ë≤∑ÂÅúÊ≠¢")
            self._funding_pause = True
        elif not in_window and self._funding_pause:
            logger.info("‚úÖ Funding passed ‚ûú Â£≤Ë≤∑ÂÜçÈñã")
            self._funding_pause = False

        return not in_window

    # ------------------------------------------------------------------
    # Funding‚Äëclose helper
    # ------------------------------------------------------------------
    def _should_close_before_funding(self, now_ts: float) -> bool:
        """Return True if we are within the configured buffer before funding."""
        next_ts = getattr(self, "next_funding_ts", None)
        if not next_ts:
            return False
        return now_ts > next_ts - self.funding_close_buffer_secs

    async def _close_all_positions(self) -> None:
        """Close every open position for this symbol."""
        try:
            state = self.exchange.info.user_state(self.account)
            coin = self.symbol.split("-")[0]
            perp_pos = next(
                (
                    p
                    for p in state.get("perpPositions", [])
                    if p["position"]["coin"] == coin
                ),
                None,
            )
            if not perp_pos:
                return
            sz = Decimal(perp_pos["position"]["sz"])
            if sz == 0:
                return  # ÊåÅ„Å°È´ò„Å™„Åó
            close_side = "SELL" if sz > 0 else "BUY"
            await self.place_order(
                side=close_side,
                size=float(abs(sz)),
                order_type="market",
                reduce_only=True,
                comment="auto‚Äëclose‚Äëbefore‚Äëfunding",
            )
            logger.info(
                "‚ö° Funding close: %s %s @ %s (buffer %s‚ÄØs)",
                close_side,
                abs(sz),
                self.symbol,
                self.funding_close_buffer_secs,
            )
        except Exception as exc:
            logger.error("close_all_positions failed: %s", exc)

    # ------------------------------------------------------------------
    # Order-price helper
    # ------------------------------------------------------------------
    def _price_with_offset(self, base_px: float, side: str) -> float:
        """
        Shift `base_px` by eps_pct toward the favourable direction.

        BUY  ‚Üí base_px * (1 - eps_pct)   („Çà„ÇäÂÆâ„ÅèË≤∑„ÅÜ)
        SELL ‚Üí base_px * (1 + eps_pct)   („Çà„ÇäÈ´ò„ÅèÂ£≤„Çã)
        """
        if side.upper() == "BUY":
            return base_px * (1 - self.eps_pct)
        return base_px * (1 + self.eps_pct)
